# path_planning.py
import heapq

class Node:
    def __init__(self, x, y, cost, parent=None):
        self.x = x
        self.y = y
        self.cost = cost
        self.parent = parent
    
    def __lt__(self, other):
        return self.cost < other.cost

def heuristic(a, b):
    # Manhattan distance
    return abs(a.x - b.x) + abs(a.y - b.y)

def astar(grid, start, goal):
    open_list = []
    closed_set = set()
    start_node = Node(start[0], start[1], 0)
    heapq.heappush(open_list, (0, start_node))
    
    while open_list:
        _, current = heapq.heappop(open_list)
        if (current.x, current.y) == goal:
            # Reconstruct path
            path = []
            while current:
                path.append((current.x, current.y))
                current = current.parent
            return path[::-1]
        
        closed_set.add((current.x, current.y))
        # 4-connected neighbors
        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
            nx, ny = current.x + dx, current.y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                if grid[nx][ny] == 1 or (nx, ny) in closed_set:
                    continue
                neighbor = Node(nx, ny, current.cost + 1, current)
                heapq.heappush(open_list, (neighbor.cost + heuristic(neighbor, Node(goal[0], goal[1],0)), neighbor))
    return None

# Example usage
if __name__ == "__main__":
    grid = [
        [0,0,0,0,0],
        [0,1,1,1,0],
        [0,0,0,0,0],
        [0,1,0,1,0],
        [0,0,0,0,0]
    ]
    start = (0,0)
    goal = (4,4)
    path = astar(grid, start, goal)
    print("Planned Path:", path)
